Task 1:
Folosindu-ma de precizarea ca "secvența conține numere consecutive distincte începand cu 1", pentru fiecare numar de la 1 la n, caut nodul cu valoarea corespunzatoare. Retin in permanenta ultimul nod procesat pentru a putea face legatura cu nodul curent la fiecare pas. De asemenea, tratez si cazul special in care nodul curent este inceput de lista.

Task 2:
Algoritmul imparte sirul de caractere in cuvinte folosind functia strtok si sorteaza folosind qsort. Functia de comparatie compara lungimea cuvintelor, iar in caz de egalitate compara lexicografic.

Task 3:
Algoritmul foloseste un loop cu i de la 1 la K, iar la fiecare pas se apeleaza kfib recursiv pentru a calcula KFib(i) si rezultatul se adauga la suma finala.

Task 4:
Am implementat un algoritm backtracking care genereaza toate submultimile. Pentru fiecare submultime valida, se formeaza un cuvant prin concatenarea tuturor cuvintelor corespunzatoare indicilor submultimii. Se verifica daca cuvantul este palindrom si, in caz afirmativ, daca este noul palindrom de lungime maxima (sau mai mic lexicografic decat actualul).
